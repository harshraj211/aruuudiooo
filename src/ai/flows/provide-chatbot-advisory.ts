
'use server';
/**
 * @fileOverview A RAG-enabled chatbot advisory AI agent for farmers.
 *
 * - provideChatbotAdvisory - A function that handles the chatbot advisory process.
 * - ProvideChatbotAdvisoryInput - The input type for the provideChatbotAdvisory function.
 * - ProvideChatbotAdvisoryOutput - The return type for the provideChatbotAdvisory function.
 */

import {ai} from '@/ai/genkit';
import { retrieve } from '@/services/knowledge-base';
import {z} from 'genkit';

const ChatHistorySchema = z.object({
    role: z.enum(['user', 'assistant']),
    text: z.string(),
});

const ProvideChatbotAdvisoryInputSchema = z.object({
  query: z.string().describe('The query from the farmer.'),
  managementType: z.enum(['Crops', 'Fruits']).describe('The management context (Crops or Fruits).'),
  photoDataUri: z
    .string()
    .optional()
    .describe(
      "An optional photo provided by the user, as a data URI that must include a MIME type and use Base64 encoding. Expected format: 'data:<mimetype>;base64,<encoded_data>'."
    ),
  documentContent: z
    .string()
    .optional()
    .describe("Optional text content from a user-uploaded document."),
  history: z.array(ChatHistorySchema).optional().describe('The entire previous conversation history for context.'),
});
export type ProvideChatbotAdvisoryInput = z.infer<typeof ProvideChatbotAdvisoryInputSchema>;

const ProvideChatbotAdvisoryOutputSchema = z.object({
  advice: z.string().describe('The advice generated by the chatbot.'),
});
export type ProvideChatbotAdvisoryOutput = z.infer<typeof ProvideChatbotAdvisoryOutputSchema>;

export async function provideChatbotAdvisory(input: ProvideChatbotAdvisoryInput): Promise<ProvideChatbotAdvisoryOutput> {
  return provideChatbotAdvisoryFlow(input);
}


const PromptInputSchema = ProvideChatbotAdvisoryInputSchema.extend({
  retrievedDocs: z.string().optional().describe('Content retrieved from the knowledge base.'),
});

const prompt = ai.definePrompt({
  name: 'provideChatbotAdvisoryPrompt',
  input: {schema: PromptInputSchema},
  output: {schema: ProvideChatbotAdvisoryOutputSchema},
  prompt: `You are an expert AI agricultural advisor chatbot named eKheti. Your goal is to provide helpful, concise, and actionable advice to farmers. You are an expert in all aspects of farming, including soil health, crop management, pest and disease control, and market trends.

  **Core Instructions & Memory:**
  - You have a perfect, long-term memory. Use the provided conversation history to maintain context, remember key facts, user preferences (like their location, primary crops), and details from any documents or images they've shared across the entire session.
  - When a user asks a question, first "search" your memory (the conversation history and any provided documents) for relevant information before answering. If they ask "What did I ask last week?" or "refer back to that document I sent", you MUST use the history to answer.
  - If a user-uploaded document is provided, its content is additional context. Answer questions based on the document's content.
  - If an image is provided, analyze it and incorporate your findings into the response. The image could be anything from a diseased plant, a type of soil, an insect, or a farming tool.
  - If you do not know the answer, say so. Do not make up information.
  - Format your response using markdown for better readability (e.g., use **bold** for emphasis, lists for steps).
  - Respond in the user's language if it is not English. Be conversational and friendly.
  
  {{#if retrievedDocs}}
  **Knowledge Base Information:**
  Before formulating your final answer, consult the following information retrieved from our agricultural knowledge base. This is your primary source of truth.
  ---
  {{{retrievedDocs}}}
  ---
  {{/if}}

  **Conversation History (Your Memory):**
  {{#if history}}
    {{#each history}}
      {{this.role}}: {{this.text}}
    {{/each}}
  {{else}}
    This is the beginning of the conversation.
  {{/if}}

  {{#if documentContent}}
  The user has also uploaded a document. Its content is additional context for the current query.
  Document Content:
  ---
  {{{documentContent}}}
  ---
  {{/if}}

  Current User Query:
  Text: {{{query}}}
  {{#if photoDataUri}}
  Image: {{media url=photoDataUri}}
  {{/if}}
  
  Your expert advice:`,
});

const provideChatbotAdvisoryFlow = ai.defineFlow(
  {
    name: 'provideChatbotAdvisoryFlow',
    inputSchema: ProvideChatbotAdvisoryInputSchema,
    outputSchema: ProvideChatbotAdvisoryOutputSchema,
  },
  async input => {
    // 1. Retrieve relevant documents from the knowledge base
    const relevantDocs = await retrieve({
        query: input.query,
        managementType: input.managementType,
    });
    
    // Format the retrieved docs for the prompt
    const retrievedDocsContent = relevantDocs.map(
        (doc, i) => `[Source ${i + 1}]: ${doc.text()}`
    ).join('\n\n');


    // 2. Call the prompt with the retrieved documents
    const {output} = await prompt({
        ...input,
        retrievedDocs: retrievedDocsContent,
    });
    
    return output!;
  }
);
